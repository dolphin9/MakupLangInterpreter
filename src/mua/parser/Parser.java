package mua.parser;

import mua.Context;
import mua.lexer.LexicalErrorException;
import mua.lexer.ListToken;
import mua.lexer.Token;

import java.util.Queue;
import java.util.Stack;

public class Parser {
    private Context mContext;

    public Parser(Context context) {
        mContext = context;
    }

    /**
     * It generates a parse tree from a given token list.
     *
     * @param tokens the token list generated by the lexer.
     * @return the parse tree
     * @throws SyntaxErrorException
     * @throws LexicalErrorException
     */
    public ParseTree parse(Queue<Token> tokens) throws SyntaxErrorException, LexicalErrorException {
        Stack<OperatorNode> opNodeStack = new Stack<>();
        OperatorNode root = null;
        while (!tokens.isEmpty()) {
            // Extract an operator node (the root) from the first token, which must be a string token.
            Token token = tokens.poll();
            if (!token.isString())
                throw new UnknownOperatorException();
            String tokenStr = (String) token.getValue();
            root = OperatorNode.extract(tokenStr);
            opNodeStack.push(root);
            while (!opNodeStack.isEmpty()) {
                // Pop an operator node from the stack. Eat the next tokens if
                // it need more arguments, else the operator is finished, and
                // popped from the stack.
                OperatorNode op = opNodeStack.peek();
                if (op.needsMoreArguments()) {
                    // If it need more arguments and the token list is empty,
                    // the command is incomplete, and a next line should be
                    // received from the input.
                    while (tokens.isEmpty()) {
                        // If it is a nested sentence, it throws an exception.
                        if (mContext.isNested())
                            throw new MissingArgumentException();
                        tokens = mContext.parserWait();
                    }
                    ParseNode node = parse(tokens.poll());
                    if (node.isOperator() && ((OperatorNode) node).needsMoreArguments())
                        // For an operator node, push it into the stack.
                        opNodeStack.push((OperatorNode) node);
                    else
                        // for an ordinary node, add it to the argument list of
                        // the current operator node.
                        op.addArgument(node);
                } else {
                    // If the operator needs no more arguments, it is finished
                    // and will be popped from the stack, and add to the argument
                    // list of the last layer, or set it the root.
                    opNodeStack.pop();
                    if (!opNodeStack.empty()) {
                        opNodeStack.peek().addArgument(op);
                    } else
                        root = op;
                }
            }
            if (!tokens.isEmpty()) {
                // if a whole command is taken and the token list is not empty,
                // the command is executed immediately.
                mContext.run(root);
                root = null;
            }
        }

        return new ParseTree(root);
    }

    /**
     * It parses the given token into a value node.
     *
     * @param token the token to be parsed.
     * @return the parsed value node.
     * @throws SyntaxErrorException
     */
    public ValueNode parse(Token token) throws SyntaxErrorException {
        if (token.isString()) {
            String tokenStr = (String) token.getValue();
            try {
                return OperatorNode.extract(tokenStr);
            } catch (UnknownOperatorException e) {
                return new StringNode(tokenStr);
            }
        } else if (token.isNumber()) {
            return new NumberNode((Number) token.getValue());
        } else if (token.isList()) {
            return new ListNode((ListToken) token);
        } else
            throw new InvalidArgumentTypeException();
    }
}

